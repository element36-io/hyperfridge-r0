use risc0_zkvm::Receipt;
use std::env;
use std::fs;

// generated by test cases
const DEFAULT_PROOF_JSON: &str = "../data/test/test.xml-Receipt";

// generated by test cases, "HYPERFRIDGE_ID"
const DEFAULT_ID_HEX: &str = "../host/out/IMAGE_ID.hex";
// in case of docker, IMAGE_ID.hex resides with verifier in /app
const FALLBACK_ID_HEX: &str = "./IMAGE_ID.hex";

/// Verify a receipt. If no parameters are presented, use standard values
/// generated by test cases which are included in release.
fn main() {
    println!("Start Verify");
    // Get the first argument from command line, if available
    let args: Vec<String> = env::args().collect();
    let proof_json_path = if args.len() > 1 {
        &args[1]
    } else {
        println!("no receipt provided - using file  {}", DEFAULT_PROOF_JSON);
        DEFAULT_PROOF_JSON
    };

    let image_id_hex = get_image_id_hex(&args);

    let receipt_json: Vec<u8> = fs::read(proof_json_path)
        .unwrap_or_else(|_| panic!("Failed to read file at {}", proof_json_path));

    let receipt: Receipt =
        serde_json::from_slice(&receipt_json).expect("Failed to parse proof JSON");
    let result_string = String::from_utf8(receipt.journal.bytes.clone())
        .expect("Failed to convert bytes to string");
    println!("Commitments in receipt: {}", result_string);
    let image_id_array =
        hex_to_u32_array(&image_id_hex).expect("Failed to convert hex to u32 array");

    receipt
        .verify(image_id_array)
        .expect(&format!("verify failed with image id: {}", &image_id_hex));
}

fn hex_to_u32_array(hex_str: &str) -> Result<[u32; 8], &'static str> {
    if hex_str.len() != 64 {
        return Err("Hex string must be exactly 64 characters long");
    }

    let mut array = [0u32; 8];
    for (i, chunk) in hex_str.as_bytes().chunks(8).enumerate() {
        let chunk_str = std::str::from_utf8(chunk).map_err(|_| "Invalid UTF-8 sequence")?;
        array[i] = u32::from_str_radix(chunk_str, 16).map_err(|_| "Failed to parse hex as u32")?;
    }

    Ok(array)
}

/// Get Image ID as HEX from cli parameter or generated files
/// R
fn get_image_id_hex(args: &[String]) -> String {
    if args.len() > 2 {
        println!(" use image ID from CLI parameter ");
        args[2].clone()
    } else {
        match fs::read_to_string(DEFAULT_ID_HEX) {
            Ok(file_content) => {
                println!(
                    "no image ID provided - using image ID from file  {}",
                    DEFAULT_ID_HEX
                );
                file_content
            }
            Err(_) => {
                match fs::read_to_string(FALLBACK_ID_HEX) {
                    Ok(file_content) => {
                        println!(
                            "no image id provided - using image ID from file  {}",
                            FALLBACK_ID_HEX
                        );
                        file_content
                    }
                    Err(e) => {
                        eprintln!("Failed to read the fallback file: {}", e);
                        std::process::exit(1); // Exit if unable to read the file
                    }
                }
            }
        }
    }
}
