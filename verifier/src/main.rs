//! Verify a hyperfride proof json file.
//!
//!
//! ```bash
//! verifier
//! //! df
//! ```

use clap::{Parser, Subcommand};
use risc0_zkvm::Receipt;
use serde::Deserialize;
use std::{fs, path::PathBuf};

// generated by test cases, "HYPERFRIDGE_ID"
const DEFAULT_ID_HEX: &str = "../host/out/IMAGE_ID.hex";

// in case of docker, IMAGE_ID.hex resides with verifier in /app
const FALLBACK_ID_HEX: &str = "./IMAGE_ID.hex";

static mut VERBOSE: bool = false; // print verbose or not

macro_rules! v {
    ($($arg:tt)*) => {
        unsafe {
            if VERBOSE {
                println!($($arg)*);
            }
        }
    };
}

///  Commitment object would look like this:
///
/// # Examples
///
/// ```json
/// {
///     "hostinfo": "host:main",
///     "iban": "CH4308307000289537312",
///     "stmts": [
///         {
///             "elctrnc_seq_nb": "247",
///             "fr_dt_tm": "2023-11-29T00:00:00",
///             "to_dt_tm": "2023-11-29T00:00:00",
///             "amt": "31709.14",
///             "ccy": "CHF",
///             "cd": "OPBD"
///         },
///         {
///             "elctrnc_seq_nb": "248",
///             "fr_dt_tm": "2023-11-30T00:00:00",
///             "to_dt_tm": "2023-11-30T00:00:00",
///             "amt": "31709.09",
///             "ccy": "CHF",
///             "cd": "OPBD"
///         }
///     ]
/// }
/// ```
#[derive(Deserialize, Debug)]
#[allow(dead_code)]
struct Commitment {
    hostinfo: String,
    iban: String,
    stmts: Vec<Stmt>,
}

#[derive(Deserialize, Debug)]
#[allow(dead_code)]
struct Stmt {
    elctrnc_seq_nb: String,
    fr_dt_tm: String,
    to_dt_tm: String,
    amt: String,
    ccy: String,
    cd: String,
}

/// Verify a receipt. If no parameters are presented, use standard values
/// generated by test cases which are included in release.
///verbose
fn main() {
    let cli = parse_cli();

    if cli.markdown_help {
        clap_markdown::print_help_markdown::<Cli>();
        std::process::exit(0);
    }

    let proof_json_path: PathBuf;
    let image_id_hex;

    match &cli.command {
        Some(Commands::Verify {
            imageid_hex,
            proof_json,
        }) => {
            println!("verify {} {:?}", imageid_hex, proof_json);
            image_id_hex = imageid_hex.clone();
            proof_json_path = proof_json
                .clone()
                .unwrap_or_else(|| panic!("Proof JSON not provided"));
        }
        Some(Commands::Test) => {
            image_id_hex = get_image_id_hex_from_file();
            proof_json_path = PathBuf::from(format!(
                "../data/test/test.xml-Receipt-{}-latest.json",
                image_id_hex
            ));
        }
        None => {
            panic!("No command given");
        }
    }

    let receipt_json: Vec<u8> = fs::read(&proof_json_path)
        .unwrap_or_else(|_| panic!("Failed to read file at {:?}", proof_json_path.to_str()));

    let receipt: Receipt =
        serde_json::from_slice(&receipt_json).expect("Failed to parse proof JSON");

    let image_id_array =
        hex_to_u32_array(&image_id_hex).expect("Failed to convert hex to u32 array");

    receipt
        .verify(image_id_array)
        .unwrap_or_else(|_| panic!("verify failed with image id: {}", &image_id_hex));

    println!("{:?}", get_commitment(receipt));
}

fn hex_to_u32_array(hex_str: &str) -> Result<[u32; 8], &'static str> {
    if hex_str.len() != 64 {
        return Err("Hex string must be exactly 64 characters long");
    }

    let mut array = [0u32; 8];
    for (i, chunk) in hex_str.as_bytes().chunks(8).enumerate() {
        let chunk_str = std::str::from_utf8(chunk).map_err(|_| "Invalid UTF-8 sequence")?;
        array[i] = u32::from_str_radix(chunk_str, 16).map_err(|_| "Failed to parse hex as u32")?;
    }

    Ok(array)
}

/// Get Image ID as HEX
fn get_image_id_hex_from_file() -> String {
    match fs::read_to_string(DEFAULT_ID_HEX) {
        Ok(file_content) => {
            v!(
                "no image ID provided - using image ID from file  {}",
                DEFAULT_ID_HEX
            );
            file_content
        }
        Err(_) => {
            match fs::read_to_string(FALLBACK_ID_HEX) {
                Ok(file_content) => {
                    v!(
                        "no image id provided - using image ID from file  {}",
                        FALLBACK_ID_HEX
                    );
                    file_content
                }
                Err(e) => {
                    v!("Failed to read the fallback file: {}", e);
                    std::process::exit(1); // Exit if unable to read the file
                }
            }
        }
    }
}

/// Read public commitment from receipt
fn get_commitment(receipt: Receipt) -> Result<Commitment, serde_json::Error> {
    // for some reason there are other characters at the beginning of the commitment remove that
    let commitment_string = {
        let bytes = &receipt.journal.bytes;
        let start_index = bytes.iter().position(|&b| b == b'{').unwrap_or(0);
        let end_index = bytes
            .iter()
            .rposition(|&b| b == b'}')
            .unwrap_or(bytes.len());
        String::from_utf8(bytes[start_index..=end_index].to_vec())
            .expect("Failed to convert bytes to string from journal in main")
    };
    v!("Commitments in receipt: {}", commitment_string);

    serde_json::from_str(&commitment_string)
}

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
#[clap(version = "1.0", author = "Hyperfridge")]
#[command(arg_required_else_help(true))]
struct Cli {
    #[arg(
        short,
        long,
        default_value = "false",
        help = "verbose mode, false will only print the commitment as json"
    )]
    verbose: bool,
    #[arg(long, hide = true)]
    markdown_help: bool,
    #[command(subcommand)]
    command: Option<Commands>,
}

// https://docs.rs/clap/latest/clap/struct.Arg.html
#[derive(Subcommand, Debug)]
enum Commands {
    /// Validates a proof generated by a sealed risc0 elf binary.
    Verify {
        #[arg(
            short,
            long,
            help = "The image ID of the risk0 image. Look for IMAGE_ID.hex file in the hyperfridge package of the proover o which image ID it is pinned.",
            required = true
        )]
        imageid_hex: String,
        #[arg(
            short,
            long,
            help = "Risc0 proof file as json, generated by hyperfridge binary.",
            value_name = "FILE",
            required = true
        )]
        proof_json: Option<PathBuf>,
    },
    /// Uses test data - you may need RISC0_DEV_MODE=true environment variable
    Test,
}

fn parse_cli() -> Cli {
    let cli = Cli::parse();

    unsafe {
        VERBOSE = cli.verbose;
    }
    cli
}
