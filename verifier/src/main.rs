use risc0_zkvm::Receipt;
use serde::Deserialize;
use std::env;
use std::fs;

// generated by test cases, "HYPERFRIDGE_ID"
const DEFAULT_ID_HEX: &str = "../host/out/IMAGE_ID.hex";
// in case of docker, IMAGE_ID.hex resides with verifier in /app
const FALLBACK_ID_HEX: &str = "./IMAGE_ID.hex";

///  Commitment object would look like this:
///
/// # Examples
///
/// ```json
/// {
///     "hostinfo": "host:main",
///     "iban": "CH4308307000289537312",
///     "stmts": [
///         {
///             "elctrnc_seq_nb": "247",
///             "fr_dt_tm": "2023-11-29T00:00:00",
///             "to_dt_tm": "2023-11-29T00:00:00",
///             "amt": "31709.14",
///             "ccy": "CHF",
///             "cd": "OPBD"
///         },
///         {
///             "elctrnc_seq_nb": "248",
///             "fr_dt_tm": "2023-11-30T00:00:00",
///             "to_dt_tm": "2023-11-30T00:00:00",
///             "amt": "31709.09",
///             "ccy": "CHF",
///             "cd": "OPBD"
///         }
///     ]
/// }
/// ```
#[derive(Deserialize, Debug)]
#[allow(dead_code)]
struct Commitment {
    hostinfo: String,
    iban: String,
    stmts: Vec<Stmt>,
}

#[derive(Deserialize, Debug)]
#[allow(dead_code)]
struct Stmt {
    elctrnc_seq_nb: String,
    fr_dt_tm: String,
    to_dt_tm: String,
    amt: String,
    ccy: String,
    cd: String,
}

/// Verify a receipt. If no parameters are presented, use standard values
/// generated by test cases which are included in release.
///
fn main() { 
    
    let args: Vec<String> = env::args().collect();

    let image_id_hex = get_image_id_hex(&args);

    // Get the first argument from command line, if available
    let mut proof_json_path = format!("../data/test/test.xml-Receipt-{}-latest.json", image_id_hex);

    if args.len() > 1 {
        proof_json_path = args[1].clone();
    } else {
        println!(
            "No Proof-json provided,  validate test file: {}",
            &proof_json_path
        );
        println!("you might need RISC0_DEV_MODE=true when you want to validate a test proof.");
    }

    let receipt_json: Vec<u8> = fs::read(&proof_json_path)
        .unwrap_or_else(|_| panic!("Failed to read file at {}", proof_json_path));

    let receipt: Receipt =
        serde_json::from_slice(&receipt_json).expect("Failed to parse proof JSON");

    let image_id_array =
        hex_to_u32_array(&image_id_hex).expect("Failed to convert hex to u32 array");

    receipt
        .verify(image_id_array)
        .unwrap_or_else(|_| panic!("verify failed with image id: {}", &image_id_hex));


    println!("{:?}", get_commitment(receipt));
}

fn hex_to_u32_array(hex_str: &str) -> Result<[u32; 8], &'static str> {
    if hex_str.len() != 64 {
        return Err("Hex string must be exactly 64 characters long");
    }

    let mut array = [0u32; 8];
    for (i, chunk) in hex_str.as_bytes().chunks(8).enumerate() {
        let chunk_str = std::str::from_utf8(chunk).map_err(|_| "Invalid UTF-8 sequence")?;
        array[i] = u32::from_str_radix(chunk_str, 16).map_err(|_| "Failed to parse hex as u32")?;
    }

    Ok(array)
}

/// Get Image ID as HEX
fn get_image_id_hex(args: &[String]) -> String {
    if args.len() > 2 {
        println!(" use image ID from CLI parameter ");
        args[2].clone()
    } else {
        match fs::read_to_string(DEFAULT_ID_HEX) {
            Ok(file_content) => {
                println!(
                    "no image ID provided - using image ID from file  {}",
                    DEFAULT_ID_HEX
                );
                file_content
            }
            Err(_) => {
                match fs::read_to_string(FALLBACK_ID_HEX) {
                    Ok(file_content) => {
                        println!(
                            "no image id provided - using image ID from file  {}",
                            FALLBACK_ID_HEX
                        );
                        file_content
                    }
                    Err(e) => {
                        eprintln!("Failed to read the fallback file: {}", e);
                        std::process::exit(1); // Exit if unable to read the file
                    }
                }
            }
        }
    }
}


/// Read public commitment from receipt
fn get_commitment(receipt: Receipt) -> Result<Commitment, serde_json::Error> {
    // for some reason there are other characters at the beginning of the commitment remove that
    let commitment_string = {
        let bytes = &receipt.journal.bytes;
        let start_index = bytes.iter().position(|&b| b == b'{').unwrap_or(0);
        let end_index = bytes
            .iter()
            .rposition(|&b| b == b'}')
            .unwrap_or(bytes.len());
        String::from_utf8(bytes[start_index..=end_index].to_vec())
            .expect("Failed to convert bytes to string from journal in main")
    };
    println!("Commitments in receipt: {}", commitment_string);

    serde_json::from_str(&commitment_string)
}
