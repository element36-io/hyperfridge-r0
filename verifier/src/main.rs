use risc0_zkvm::Receipt;
#[allow(unused_imports)]
use risc0_zkvm::{default_prover, ExecutorEnv};
use std::env;
use std::fs;

// generated by test cases
const DEFAULT_PROOF_JSON: &str = "../data/test/test.xml-Receipt";

// generated by test cases, "HYPERFRIDGE_ID"
const DEFAULT_ID_HEX: &str = "../host/out/IMAGE_ID.hex";
// in case of docker, IMAGE_ID.hex resides with verifier in /app 
//const FALLBACK_ID_HEX: &str = "./IMAGE_ID.hex";

fn main() {
    println!("Start Verify");
    // Get the first argument from command line, if available
    let args: Vec<String> = env::args().collect();
    let proof_json_path = if args.len() > 1 {
        &args[1]
    } else {
        DEFAULT_PROOF_JSON
    };

    let image_id_hex = if args.len() > 2 {
        args[2].clone()
    } else {
        match fs::read_to_string(DEFAULT_ID_HEX) {
            Ok(file_content) => file_content,
            Err(e) => {
                eprintln!("Failed to read the file: {}", e);
                return;
            }
        }
    };

    let receipt_json: Vec<u8> = fs::read(proof_json_path)
        .unwrap_or_else(|_| panic!("Failed to read file at {}", proof_json_path));

    let receipt: Receipt =
        serde_json::from_slice(&receipt_json).expect("Failed to parse proof JSON");
    let result_string = String::from_utf8(receipt.journal.bytes.clone())
        .expect("Failed to convert bytes to string");
    println!("Commitments in receipt: {}", result_string);
    let image_id_array =
        hex_to_u32_array(&image_id_hex).expect("Failed to convert hex to u32 array");

    receipt.verify(image_id_array).expect(&format!(
        "verify failed - image id used is: {}",
        &image_id_hex
    ));
}

fn hex_to_u32_array(hex_str: &str) -> Result<[u32; 8], &'static str> {
    if hex_str.len() != 64 {
        return Err("Hex string must be exactly 64 characters long");
    }

    let mut array = [0u32; 8];
    for (i, chunk) in hex_str.as_bytes().chunks(8).enumerate() {
        let chunk_str = std::str::from_utf8(chunk).map_err(|_| "Invalid UTF-8 sequence")?;
        array[i] = u32::from_str_radix(chunk_str, 16).map_err(|_| "Failed to parse hex as u32")?;
    }

    Ok(array)
}
