# Highlevel cryptographic process description

## Intoducing the witness role

The EBICS Specifaction does not enforce encryption of the payload (bank statements).Therefore the client is able to change for example balances or transactions and create a valid proof the the data. We use the concept of a witness (could also be names as signing proxy), which interacts with the bank on the clients behalf without knowing the private key of the client. The witness uses an HSM (Hardware Security Module, e.g. Google HSM) secured by a token to sign messages for the client and exchange data with the bank.

Ebics standard plans the signing of the payload, which would make the witness superluss.  The schema-definitions already contain a placeholder, but they are dactivated using 'maxoccurs=0':

File 'ebics_orders_H005.xsd':

'''xml
<element name="SignatureData" minOccurs="0" maxOccurs="0">
   <annotation>
      <documentation xml:lang="de">enth√§lt Signaturdaten (EUs).</documentation>
      <documentation xml:lang="en">contains signature data (ESs).</documentation>
   </annotation>
   <complexType>
      <simpleContent>
         <extension base="ebics:SignatureDataType">
            <attributeGroup ref="ebics:AuthenticationMarker"/>
         </extension>
      </simpleContent>
   </complexType>
</element>
'''

But the setup is able to work on more generic matter, e.g. also proving Stripe API call
or other API documents.

## Entities

1. **Client (`C`)**:
   - Private Key: $C_{{priv}}$
   - Public Key: $C_{{pub}}$
2. **Bank (`B`)**:
   - Private Key: $B_{{priv}}$
   - Public Key: $B_{{pub}}$
3. **Witness (`W`)**:
   - Private Key: $W_{{priv}}$
   - Public Key: $W_{{pub}}$
4. **Hardware Security Module (HSM)**:
   - Provides signing functions using $C_{{priv}}$, but no decryption.
   - Request a secure token shared with the witness to be accessed.


### EBICS Encryption and Decryption Process

All messages between Client and Bank are singed XML documents. The payload is encrypted with a symetric key, whihc is shared with the client by encrypting it with the clients public key.

### Process Description when downloading payload data

1. **Symmetric Key Generation**:
    A symmetric key ${SymKey}$ is generated by the Bank to encrypt the payload.
1. **Payload Encryption**:
    The payload is encrypted using a newly created symmetric key: 
    $ {Encrypt}_{SymKey}({Payload}) \rightarrow {Payload}_{enc}$
1. **Symmetric Key Encryption**:
    The symmetric key (SymKey) is then encrypted using the Client's public key, $C_{{pub}}$.
    This ensures that only the holder of the corresponding private key can decrypt and use the symmetric key.
    Encrypted Symmetric Key: ${Encrypt}_{C_{pub}}({SymKey}) \rightarrow {SymKey}_{enc}$
1. **Create Ebics Respose**:
    After a client sends an EbicsRequest, the Bank ready to sign and send an EbicsResponse which contains : ${ebicsResponse} = {Payload}_{enc} \, \| \, {EncryptedSessionKey} \, \| \, {XMLSignature}$

### Process Description with Witness and HSM

To work on the Clients behalf, the witness needs to sign messages for the banking backend, for example it needs to create a singed EbicsRequest message, in order to get the EbicsResponse message which contains the payload.

To sign messages for the bank it uses :

4. **Request and Download EbicsResponse**
    Using the HSM, the witness is able to create the EbicsRequest by signing it with the HSM: 
    ${hsmSign}_{hsmtoken}(EbicsRquest) \rightarrow {sign}_{C_{priv}}({EbicsRequest})$
1. **Sign Encrypted Payload**
    Create signature of encrypted payload:  
    $ {Signature}_{w_{priv}} = {Sign}_{W_{priv}}({Payload}_{enc}) $


## Zero-Knowledge Proof Process

### Process Description

The witness uses hyperfridge and the HSM to create a SNARK proof with:
- ${Payload}_{enc}, {SymKey}_{enc}, {XMLSignature}$
-  $ {Signature}_{w_{priv}} $
-  And decrypted transaction key ${SymKey}$ by calling $hsmDecrypt_{hsmtoken}(Symkey_{enc})$

6. **Create STARK Proof**: ${ZKProof}_{ImageID}({PrivateInput}, {PublicInput}) \rightarrow {Commitment}$
    - Private Inputs:
        - Extracted form from ${EbicsRequest}$:  
            - ${Payload}_{enc}$: Encrypted payload, decrypt payload with ${SymKey}$ to extract the commitments.
            - $ {SymKey}_{enc}$: Encrypted symetric transaction key, assert that the HSM-decrypted symetrical key is identical to the symetrical key of the document.
            - $ {XMLSignature}, {}$: Signatures by the bank cover ${SymKey}$
        - ${Symkey}$: Decrypted symetric key which is used for speeding up decryption of ${Payload}$ and integrity check for the $Payload$
    - Public Inputs: 
      - IBAN, $B_{pub}$, $W_{pub}$

    - Commitment: Public input and data from  $Payload$ and $EbicsResponse$: ${extractCommitment}({EbicsRequest}, {Payload})$ presented as a JSON document.

The STARK presents a proof of computation. The computation is sealed (using Risk-Zero framework) and contains:

  a. **Validate $SymKey$**: The Bank has generated $SymKey$ to encrypt the $Payload$ (clients data)
   - Verify $XMLSignature$ which contains $Symkey_{enc}$.
   - Decrypt $Symkey_{enc}$ with $C_{priv}$ which proves the document was sent to the specific client.
 
  b. **Validate integrity of $Payload$**:
   - Validate $ {Signature}_{w_{priv}}$ of $Payload$ so the client is not able to tamper the $Payload$ to present a fake balance.
  
  c. **Create commitment from decrypted $Payload$**:
   - Decrypt $Payload$ with $Symkey$.
   - Extract the data from payload and create the commitment. 
   - Add public input to the commitment.
  
  d. **A seal for the proofing algorithm - the $ImageID$**
   - The seal (exact version and code) is identified by an $ImageID$. 
   - See [Risk-Zero Proof System](https://dev.risczero.com/proof-system/).

### Verification

7. **Verification using Risk-Zero Recipie**: Other parties (like the Bank or external verifiers) can verify the zero-knowledge proof.
   - Verify proof with: ${VerifyZKProof_{ImageID}}() \rightarrow Commitment$.
   - Check the public input (IBAN, $B_{pub}$, $W_{pub}$).


(8.) **On-Chain verification with Groth16 SNARK**:
   - Risk-Zero privides a STARK to SNARK wrapper to support [on-chain verfication](https://www.risczero.com/news/on-chain-verification).


## Key Benefits
   - **Privacy**: The Client's private key remain confidential throughout the process. No party has access to any of the others private keys. The witness is not able to see the payload. 
   - **Security**: The signature from the Witness and the zero-knowledge proof mechanism ensure the security and integrity of the transaction without compromising sensitive information (transaction data).
- **Verifiability**: External parties can verify a bank statements legitimacy without accessing private keys or sensitive transaction details - on-chain or off-chain. 



## Security Considerations

- The witness also acts as a signing proxy to create the $EbicsRequest$ which is necessary to trigger the download of $EbicsResponse$ which contains the $Payload$. It is important to set up the HSM in a way that the witness is able to sign, but not decrypt any message.
- The zero-knowledge proof allows the Client to prove knowledge of certain information without revealing the information itself.
- The use of digital signatures by the Witness ensures the integrity and authenticity of the payload, which might not be necessary if the Ebics Standard implements its planned feature.
- The HSM must be tamper-resistant and capable of securely managing cryptographic keys and operations.
- Secure communication protocols should be used to prevent unauthorized access and interception.

## Outlook and use cases

- iOS / HSM
- other data
- TLS block cipher; 
