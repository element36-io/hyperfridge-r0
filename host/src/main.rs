
// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{
    HYPERFRIDGE_ELF, HYPERFRIDGE_ID // TODO: does not work, why? HYPERFRIDGE_ID
};
use risc0_zkvm::{default_prover, ExecutorEnv};
use pem::parse;
use rsa::RsaPublicKey; 
use rsa::pkcs8::DecodePublicKey;
use rsa::traits::PublicKeyParts;
use std::fs;

#[cfg(not(test))] 
use chrono::Local;
#[cfg(not(test))] 
use std::env;




#[cfg(not(test))] 
fn main() {

    println!("start: {}", Local::now().format("%Y-%m-%d %H:%M:%S"));

    let args: Vec<String> = env::args().collect();
    // Ensure there are enough arguments
    if args.len() < 3 {
        eprintln!("Usage: program<bank_public_key> <user_private_key> <ebics_response_xml>");
        eprintln!("To use with test data use parameters: ../data/test/test.xml ../data/bank_public.pem ../data/client.pem");
        return;
    }

    //<SignedInfo> <authenticated> <SignatureValue> <OrderData> 
    // Load files based on command-line arguments
    let bank_public_key_x002_pem = fs::read_to_string(&args[2]).expect("Failed to read bank_public_key file");
    let user_private_key_e002_pem = fs::read_to_string(&args[3]).expect("Failed to read user_private_key file");
    
    let signed_info_xml_c14n =  fs::read_to_string(args[1].to_string()+"-SignedInfo").expect("Failed to read SignedInfo file") ;
    let authenticated_xml_c14n = fs::read_to_string(args[1].to_string()+"-authenticated").expect("Failed to read authenticated file");
    let signature_value_xml = fs::read_to_string(args[1].to_string()+"-SignatureValue").expect("Failed to read SignatureValue file") ;
    let order_data_xml =  fs::read_to_string(args[1].to_string()+"-OrderData").expect("Failed to read OrderData file") ;
 

    let _ = proove_camt53(
        &signed_info_xml_c14n,
        &authenticated_xml_c14n,
        &signature_value_xml,
        &order_data_xml,
        &bank_public_key_x002_pem,
        &user_private_key_e002_pem,
    );
    println!("end: {}", Local::now().format("%Y-%m-%d %H:%M:%S"));
}

fn proove_camt53(
    signed_info_xml_c14n: &str,
    authenticated_xml_c14n: &str,
    signature_value_xml: &str,
    order_data_xml: &str,
    bank_public_key_x002_pem: &str,
    user_private_key_e002_pem: &str,
) -> String {


    // Using crypto-bigint does not work with RsaPUblicKey

    // let exp_bigint = BigInt::from_str_radix(&BANK_X002_EXP, 10)
    // .expect("error parsing EXP of public bank key");
    // let modu_bigint = BigInt::from_str_radix(&BANK_X002_MOD, 10)
    // .expect("error parsing MODULUS of public bank key");

    // let exp_hex = format!("{:x}", exp_bigint);
    // let modu_hex = format!("{:x}", modu_bigint);

    // .write(&exp_hex).unwrap()
    // .write(&modu_hex).unwrap()

    // https://docs.rs/risc0-zkvm/latest/risc0_zkvm/struct.ExecutorEnvBuilder.html
    println!("Starting guest code, load environment");
    env_logger::init();
    let pem = parse(&bank_public_key_x002_pem).expect("Failed to parse bank public key PEM");
    let bank_public_key = RsaPublicKey::from_public_key_pem(&pem::encode(&pem)).expect("Failed to create bank public key");
    let modulus_str = bank_public_key.n().to_str_radix(10);
    let exponent_str = bank_public_key.e().to_str_radix(10);

    let env = ExecutorEnv::builder()
        .write(&signed_info_xml_c14n).unwrap()
        .write(&authenticated_xml_c14n).unwrap()
        .write(&signature_value_xml).unwrap()
        .write(&order_data_xml).unwrap()
        .write(&modulus_str).unwrap()
        .write(&exponent_str).unwrap()
        .write(&user_private_key_e002_pem).unwrap()
        .build().unwrap();

    // Obtain the default prover.
    let prover = default_prover();
    println!("prove hyperfridge elf "); 
    let receipt_result = prover.prove_elf(env, HYPERFRIDGE_ELF);
    println!("got the receipt of the prove ");
    // println!("----- got result {} ",receipt_result);

    let mut result=String::new();
     match &receipt_result {
        Ok(_val) => {
            // println!("Receipt result: {}", val);_
            let receipt = receipt_result.unwrap();
            println!("verify receipt: ");
            let _=receipt.verify(HYPERFRIDGE_ID).expect("verify failed");
            let journal= receipt.journal;
            result=journal.decode::<String>().unwrap();
            println!("Receipt result - balance information {}", result);
            

            //println!("Receipt result: {:?}", receipt.journal.decode().unwrap());

        },
        Err(e) => {
            println!("Receipt error: {:?}", e);
            //None
        },
    }

    result
    // 31709.14

}


#[cfg(test)]
mod tests {
    use crate::{proove_camt53};
    use crate::fs;

    #[test]
    fn do_main() {
        const EBICS_FILE:&str="../data/test/test.xml";

        assert_eq!(proove_camt53(
            fs::read_to_string(EBICS_FILE.to_string()+"-SignedInfo").unwrap().as_str(),
            fs::read_to_string(EBICS_FILE.to_string()+"-authenticated").unwrap().as_str(), 
            fs::read_to_string(EBICS_FILE.to_string()+"-SignatureValue").unwrap().as_str(),
            fs::read_to_string(EBICS_FILE.to_string()+"-OrderData").unwrap().as_str(),
            fs::read_to_string("../data/bank_public.pem").unwrap().as_str(),
            fs::read_to_string("../data/client.pem").unwrap().as_str(),
        ),"31709.14");

        eprintln!("To use with test data: ../../data/test/test.xml ../../data/bank_public.pem ../../data/client.pem  ");
        return;
        // let data = include_str!("../res/example.json");
        // let outputs = super::search_json(data);
        // assert_eq!(
        //     outputs.data, 47,
        //     "Did not find the expected value in the critical_data field"
        // );
    }
}



// fn main() {
//         // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
//         env_logger::init();
    
//         // An executor environment describes the configurations for the zkVM
//         // including program inputs.
//         // An default ExecutorEnv can be created like so:
//         // `let env = ExecutorEnv::builder().build().unwrap();`
//         // However, this `env` does not have any inputs.
//         //
//         // To add add guest input to the executor environment, use
//         // ExecutorEnvBuilder::write().
//         // To access this method, you'll need to use ExecutorEnv::builder(), which
//         // creates an ExecutorEnvBuilder. When you're done adding input, call
//         // ExecutorEnvBuilder::build().
    
//         // For example:
//         let input: u32 = 15*2^27 + 1;
//         let env = ExecutorEnv::builder().write(&input).unwrap().build().unwrap();
    
//         // Obtain the default prover.
//         let prover = default_prover();
    
//         // Produce a receipt by proving the specified ELF binary.
//         let receipt = prover.prove_elf(env, HYPERFRIDGE_ELF).unwrap();
    
//         // TODO: Implement code for retrieving receipt journal here.
    
//         // For example:
//         let _output: u32 = receipt.journal.decode().unwrap();
    
//         // Optional: Verify receipt to confirm that recipients will also be able to
//         // verify your receipt
//         receipt.verify(HYPERFRIDGE_ID).unwrap();
//     }